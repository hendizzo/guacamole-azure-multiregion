# Deployment Options Comparison

## Overview
This repository now offers **TWO** deployment methods:

1. **PowerShell + Azure CLI** (Original) - `deploy-complete.ps1`
2. **Bash + Bicep** (New) - `deploy.sh` + Bicep templates

## Quick Comparison

| Feature | PowerShell + Azure CLI | Bash + Bicep |
|---------|----------------------|--------------|
| **Best for** | Windows users | Linux/Mac users, IaC practitioners |
| **Orchestration** | PowerShell script | Bash script |
| **Infrastructure** | Azure CLI commands (imperative) | Bicep templates (declarative) |
| **State Management** | JSON file (`.deployment-state.json`) | Azure resource state (no local file) |
| **VM Installation** | SSH + SCP bash script | Custom Script Extension from GitHub |
| **Idempotency** | Manual (via state file) | Built-in (Bicep) |
| **Cross-platform** | Requires PowerShell Core | Native bash (Linux/Mac) |
| **Rollback** | Manual | Azure deployment history |
| **Deployment Time** | ~20-25 minutes | ~20-25 minutes |
| **Complexity** | Medium (procedural) | Low (declarative) |
| **Maintainability** | Medium | High (IaC) |

## PowerShell + Azure CLI (`deploy-complete.ps1`)

### When to Use
- ✅ You're on Windows and prefer PowerShell
- ✅ You want step-by-step procedural control
- ✅ You're familiar with PowerShell syntax
- ✅ You need to debug individual Azure CLI commands

### How It Works
```powershell
.\deploy-complete.ps1
```

1. PowerShell script prompts for configuration
2. Creates resources via `az` CLI commands (one by one)
3. Saves state to `.deployment-state.json`
4. Generates bash scripts and copies via SCP
5. SSHs into each VM to run installation
6. Creates Front Door via Azure CLI
7. Returns URLs

### Architecture
```
deploy-complete.ps1
  ├─ Prompts user
  ├─ az group create (per region)
  ├─ az network vnet create
  ├─ az vm create
  ├─ SCP install script
  ├─ SSH run script
  └─ az afd create...
```

### Pros
- Native on Windows (no additional tools)
- Step-by-step visibility
- Can pause/resume (state file)
- Familiar for Windows admins

### Cons
- Imperative (you specify HOW to create)
- State file can get out of sync
- Longer script (700+ lines)
- Not truly idempotent
- Windows-centric

## Bash + Bicep (`deploy.sh`)

### When to Use
- ✅ You want Infrastructure as Code (IaC)
- ✅ You're on Linux/Mac
- ✅ You want idempotent deployments
- ✅ You prefer declarative configuration
- ✅ You want to version-control infrastructure

### How It Works
```bash
chmod +x deploy.sh
./deploy.sh
```

1. Bash script prompts for configuration
2. Generates Bicep parameters JSON
3. Deploys via `az deployment sub create`
4. Bicep creates all resources in parallel
5. Custom Script Extension pulls from GitHub
6. VMs self-install from repository
7. Returns URLs from Bicep outputs

### Architecture
```
deploy.sh
  ├─ Prompts user
  ├─ Generates params JSON
  └─ az deployment sub create
      ├─ main.bicep
      │   ├─ modules/region.bicep (per region)
      │   │   ├─ Network (NSG, VNet, Public IP)
      │   │   ├─ VM (Ubuntu 22.04)
      │   │   └─ Custom Script Extension
      │   │       └─ Pull install-guacamole.sh from GitHub
      │   └─ modules/frontdoor.bicep
      │       ├─ Profile
      │       ├─ Endpoint
      │       ├─ Origin Group
      │       ├─ Origins
      │       └─ Route
      └─ Returns outputs (URLs, IPs)
```

### Pros
- Declarative (you specify WHAT you want)
- Azure tracks state (no local file)
- Idempotent (safe to re-run)
- Modular (separate Bicep files)
- Version-controlled infrastructure
- Bicep validates before deployment
- Parallel resource creation
- Native on Linux/Mac
- GitHub integration (VMs pull code)

### Cons
- Requires bash, jq, Azure CLI
- Less step-by-step visibility
- Harder to debug (single deployment operation)
- Need to understand Bicep syntax

## Feature Details

### State Management

**PowerShell**:
```json
// .deployment-state.json
{
  "step": 5,
  "regions": [...],
  "domain": "example.com",
  "frontdoorEndpoint": "..."
}
```
- Stored locally
- Can drift from actual Azure state
- Manual tracking of deployment steps

**Bicep**:
- No local state file
- Azure Resource Manager tracks all resources
- Query with: `az deployment sub show --name <deployment>`
- Always in sync with actual state

### VM Installation

**PowerShell**:
```powershell
# Generate script locally
scp install-script.sh user@vm:/tmp/
ssh user@vm "bash /tmp/install-script.sh"
```
- Script generated by PowerShell
- Transferred via SCP
- Executed via SSH
- Requires SSH connectivity during deployment

**Bicep**:
```bicep
resource vmExtension 'Microsoft.Compute/virtualMachines/extensions@2023-03-01' = {
  properties: {
    settings: {
      fileUris: ['https://raw.githubusercontent.com/.../install-guacamole.sh']
    }
    protectedSettings: {
      commandToExecute: 'bash install-guacamole.sh ${domain} ${email}'
    }
  }
}
```
- Script pulled directly from GitHub
- Executed by Azure VM Agent
- No SSH required during deployment
- Always uses latest script from repo

### Idempotency

**PowerShell**:
```powershell
# Manual checks required
if (!(az group exists --name $rg)) {
    az group create...
}
```
- Need explicit existence checks
- State file can be incorrect
- Re-running may cause errors

**Bicep**:
```bicep
resource vm 'Microsoft.Compute/virtualMachines@2023-03-01' = {
  name: vmName
  properties: {...}
}
```
- Bicep handles existence checks
- Safe to re-deploy
- Updates only what changed
- Declares desired state

### Modularity

**PowerShell**:
- Single 700-line script
- Functions for reusability
- All logic in one file

**Bicep**:
- `main.bicep` (root)
- `modules/region.bicep` (reusable)
- `modules/frontdoor.bicep` (reusable)
- Clear separation of concerns

## Migration Guide

### From PowerShell to Bicep

If you've already deployed with PowerShell:

1. **Don't redeploy** - Both methods create the same infrastructure
2. **Import to Bicep** (optional):
   ```bash
   az bicep generate-params --file main.bicep --output-file existing.json
   ```

3. **Or keep PowerShell** - It works fine!

### From Bicep to PowerShell

Not recommended, but possible:
1. Note all resource names from Bicep outputs
2. Can manage with PowerShell script

## Which Should I Use?

### Choose PowerShell if:
- ✅ You're primarily on Windows
- ✅ You're comfortable with PowerShell
- ✅ You want step-by-step control
- ✅ You prefer imperative scripting
- ✅ It's already working for you

### Choose Bicep if:
- ✅ You want Infrastructure as Code
- ✅ You're on Linux/Mac (or plan to be)
- ✅ You want idempotent deployments
- ✅ You prefer declarative configuration
- ✅ You want version-controlled infrastructure
- ✅ You're starting fresh
- ✅ You work in a team (IaC is easier to share)

## Can I Use Both?

**Yes, but not recommended**. They both create resources with the same names, which will conflict. Choose one approach per deployment.

## Performance

Both methods take approximately **20-25 minutes**:
- Infrastructure creation: 5-10 minutes
- VM installation: 10-15 minutes
- SSL certificates: Included in VM installation

Bicep may be slightly faster due to parallel resource creation.

## Future Direction

The **Bicep approach is recommended** for new deployments because:
- Industry standard (Infrastructure as Code)
- Better for collaboration
- Easier to maintain
- Built-in idempotency
- Azure-native (Bicep is Microsoft's IaC language)

PowerShell will remain supported for existing users.

## Questions?

- **PowerShell**: See `README.md` and `deploy-complete.ps1`
- **Bicep**: See `BICEP-DEPLOYMENT.md` and `deploy.sh`
- **Issues**: https://github.com/hendizzo/guacamole-azure-multiregion/issues
